# Object-oriented Programming (OOP)

## 객체 지향은 인간 지향이다

우주 만물은 객체들의 합이고, 모든 것은 사물이다. -> Object\

"우리가 주변에서 사물을 인지하는 방식대로 프로그래밍할 수 있지 않겠는가" 하는 것이 객체 지향의 출발.

- 세상에 존재하는 모든 것은 사물, 즉 객체(object)다.
- 각각의 사물은 고유하다.
- 사물은 속성을 갖는다.
- 사물은 행위를 한다.

사물을 하나하나 이해하기 보다 classify(분류)해서 이해하는 것이 인간의 인지법.

---

클래스는 분류에 대한 개념이지 실체가 아니라 우리가 흔히 알고 있는 붕어빵틀과 붕어빵 비유는 사실 알맞지 않음.

## 객체지향의 4대 특성

### 추상화: 모델링

추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것.  
-> 구체적인 것을 분해해서 관심 영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링

병원 애플리케이션에서 사람은 환자이고, 은행 애플리케이션에서 사람은 고객인 것 처럼.

애플리케이션 바운더리에 따라 필요한 속성과 행위가 다르다.

실제 사물을 정확하게 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것.

### 상속: 재사용 + 확장

객체 지향의 상속은 우리고 일반적으로 알고 있는 부모 자식 관계의 상속이 아님.

상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 확장해서 사용할 수 있다는 의미.

그래서 상위 클래스 - 하위 클래스 혹은 슈퍼 클래스 - 서브 클래스라고 표현하는 것이 맞음.

상위 클래스로 갈수록 추상화, 일반화 됐다고 말하며, 하위 클래스로 갈수록 구체화, 특수화됐다고 말함.

**하위 클래스는 상위 클래스다.**

아버지는 할아버지가 아니고 아들은 아버지가 아니지만, 포유류는 동물이고, 고래는 포유류면서 동물이다. <- 이렇게 자연스럽게 설명이 가능해야함.

그래서 자바에서는 inheritance가 아닌 `extends` 라는 키워드를 쓰는 것.

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 `is a kind of` 관계를 만족해야 한다.

다중 상속은 득보다 실이 더 많았기 때문에 자바에서는 다중 상속을 지원하지 않음.

대신 인터페이스를 도입함.

인터페이스는 어떤 관계를 나타내는 것일까?

**구현 클래스 is able to 인터페이스**

상위 클래스는 하위 클래스에게 특성(속성과 메서드)을 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제함.

상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋음. (LSP와 ISP 원칙 참고)

### 다형성: 사용편의성

오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공함.

개발자가 프로그램을 작성할 때 사용편의성을 줌.

오버로딩은 함수명 하나만 가지고 인자 목록만 달리하면 되니 다형성이 지원되지 않는 언어에 비해 사용하기 편리함.

특히 제네릭을 사용하면 하나의 함수만으로 다수의 함수를 구현한 효과를 낼 수 있음.

오버라이딩의 경우 하위 클래스가 재정의한 메서드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 통해 하위 클래스가 무엇인지 신경 쓸 필요가 없고, 상위 클래스 타입의 객체 참조 변수에서도 하위 클래스가 오버라이드한 메서드를 자동으로 호출해 줌으로써 깔끔하게 유지 가능함.

### 캡슐화: 정보 은닉

---

## 객체 지향 설계 5원칙 - SOLID

도구를 올바르게 사용하는 법이 있는 것처럼 객체 지향의 특성을 올바르게 사용하기 위한 설계 원칙

## SRP - 단일 책임 원칙

"어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." - 로버트 C. 마틴

하나의 클래스가 너무 많고 다양한 역할과 책임을 가지고 있는 것을 방지하기 위해 역할(책임)을 분리하는 것.

```java
class 강아지 {
	final static Boolean 수컷 = true;
	final static Boolean 암컷 = false;
	Boolean 성별;

	void 소변보다() {
		if (this.성별 == 수컷) {
			// 한쪽 다리를 들고 소변을 본다.
		} else {
			// 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
		}
	}
}
```

위 예시를 보면 강아지가 수컷이냐 암컷이냐에 따라 소변보다() 메서드에서 분기 처리가 되는 것을 확인할 수 있음.

소변보다() 메서드가 수컷, 암컷 강아지의 행위를 모두 구현하려고 하기에 SRP를 위배하고 있는 것.

분기 처리를 위한 if else 문이 대표적인 냄새.

SRP를 적용하여 리팩터링 해보면 아래처럼 만들 수 있음.

```java
abstract class 강아지 {
	abstract void 소변보다();
}

class 수컷강아지 extends 강아지 {
	void 소변보다() {
		// 한쪽 다리를 들고 소변을 본다.
	}
}

class 암컷강아지 extends 강아지 {
	void 소변보다() {
		// 뒷다리 두 개로 앉은 자세로 소변을 본다.
	}
}
```

SRP와 가장 관계가 깊은 객체 지향 4대 특성은 추상화임.

애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 SRP를 고려하는 습관을 들여야 함.

## OCP - 개방 폐쇄 원칙

"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴

JDBC 처럼 사용하는 DBMS가 오라클에서 MySQL로 변경되더라도 Connection 정보를 수정하는 부분 외에는 클라이언트 코드는 수정할 필요가 없음.

편의점에서 일일 삼교대로 직원이 교대할 때, 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는데 영향이 없음.

유연성, 재사용성, 유지보수성 등을 얻을 수 있는 장점을 가지고 있음.

## LSP - 리스코프 치환 원칙

"서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마틴

하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다는 뜻.

객체 지향의 상속은 다음 조건들을 만족해야 함.

- 하위 클래스 is a kind of 상위 클래스
- 구현 클래스 is able to 인터페이스

```java
동물 고래 = new 고래();
동물 박쥐 = new 박쥐();
```

하위에 존재하는 것들은 상위에 있는 것들의 역할을 하는데 전혀 문제가 없음.

결국 LSP는 객체 지향의 상속 개념을 올바르게 적용하면 자연스럽게 얻게 됨.

## ISP - 인터페이스 분리 원칙

"클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다." - 로버트 C. 마틴

위의 단일 책임 원칙에서는 유지 보수에 효율적인 코드를 작성하기 위해 클래스의 역할과 책임을 분리하는 해결책을 제시하는데, 그렇게 다수의 클래스로 분리하지 않고 여러개의 인터페이스로 역할을 제한하는 방식이 ISP 임.

SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있음.

하지만 특별한 경우가 아니라면 SRP를 적용하는 것이 더 좋은 해결책임.

ISP에 대해 이야기 할 때 인터페이스 최소주의 원칙이 함께 등장하는 경우가 많음.

인터페이스 최소주의 원칙은 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공해서 해당 역할에만 충실할 수 있게 하라는 것.

상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋음.

상위 클래스가 풍성할수록 공통적으로 가지고 있는 속성과 메서드가 많아서 여기저기 형변환을 할 필요가 없어짐.

## DIP - 의존 역전 원칙

"고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."  
"추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."  
"자주 변경되는 구체 클래스에 의존하지 마라" - 로버트 C. 마틴
