# Object-oriented Programming (OOP)

**스프링 입문을 위한 자바 객체 지향의 원리와 이해 (김종민)** 을 읽고 정리한 글.

## 객체 지향은 인간 지향이다

우주 만물은 객체들의 합이고, 모든 것은 사물이다. -> Object

"우리가 주변에서 사물을 인지하는 방식대로 프로그래밍할 수 있지 않겠는가" 하는 것이 객체 지향의 출발.

- 세상에 존재하는 모든 것은 사물, 즉 객체(object)다.
- 각각의 사물은 고유하다.
- 사물은 속성을 갖는다.
- 사물은 행위를 한다.

사물을 하나하나 이해하기 보다 classify(분류)해서 이해하는 것이 인간의 인지법.

---

클래스는 분류에 대한 개념이지 실체가 아니라 우리가 흔히 알고 있는 붕어빵틀과 붕어빵 비유는 사실 알맞지 않음.

## 객체지향의 4대 특성

### 추상화: 모델링

추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것.  
-> 구체적인 것을 분해해서 관심 영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링

병원 애플리케이션에서 사람은 환자이고, 은행 애플리케이션에서 사람은 고객인 것 처럼.

애플리케이션 바운더리에 따라 필요한 속성과 행위가 다르다.

실제 사물을 정확하게 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것.

### 상속: 재사용 + 확장

객체 지향의 상속은 우리고 일반적으로 알고 있는 부모 자식 관계의 상속이 아님.

상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 확장해서 사용할 수 있다는 의미.

그래서 상위 클래스 - 하위 클래스 혹은 슈퍼 클래스 - 서브 클래스라고 표현하는 것이 맞음.

상위 클래스로 갈수록 추상화, 일반화 됐다고 말하며, 하위 클래스로 갈수록 구체화, 특수화됐다고 말함.

**하위 클래스는 상위 클래스다.**

아버지는 할아버지가 아니고 아들은 아버지가 아니지만, 포유류는 동물이고, 고래는 포유류면서 동물이다. <- 이렇게 자연스럽게 설명이 가능해야함.

그래서 자바에서는 inheritance가 아닌 `extends` 라는 키워드를 쓰는 것.

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 `is a kind of` 관계를 만족해야 한다.

다중 상속은 득보다 실이 더 많았기 때문에 자바에서는 다중 상속을 지원하지 않음.

대신 인터페이스를 도입함.

인터페이스는 어떤 관계를 나타내는 것일까?

**구현 클래스 is able to 인터페이스**

상위 클래스는 하위 클래스에게 특성(속성과 메서드)을 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제함.

상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋음. (LSP와 ISP 원칙 참고)

### 다형성: 사용편의성

오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공함.

개발자가 프로그램을 작성할 때 사용편의성을 줌.

오버로딩은 함수명 하나만 가지고 인자 목록만 달리하면 되니 다형성이 지원되지 않는 언어에 비해 사용하기 편리함.

특히 제네릭을 사용하면 하나의 함수만으로 다수의 함수를 구현한 효과를 낼 수 있음.

오버라이딩의 경우 하위 클래스가 재정의한 메서드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 통해 하위 클래스가 무엇인지 신경 쓸 필요가 없고, 상위 클래스 타입의 객체 참조 변수에서도 하위 클래스가 오버라이드한 메서드를 자동으로 호출해 줌으로써 깔끔하게 유지 가능함.

### 캡슐화: 정보 은닉

---

## 객체 지향 설계 5원칙 - SOLID

도구를 올바르게 사용하는 법이 있는 것처럼 객체 지향의 특성을 올바르게 사용하기 위한 설계 원칙

## SRP - 단일 책임 원칙

"어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." - 로버트 C. 마틴

하나의 클래스가 너무 많고 다양한 역할과 책임을 가지고 있는 것을 방지하기 위해 역할(책임)을 분리하는 것.

```java
class 강아지 {
	final static Boolean 수컷 = true;
	final static Boolean 암컷 = false;
	Boolean 성별;

void 소변보다() {
	if (this.성별 == 수컷) {
		// 한쪽 다리를 들고 소변을 본다.
	} else {
		// 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
	}
}
```

위 예시를 보면 강아지가 수컷이냐 암컷이냐에 따라 소변보다() 메서드에서 분기 처리가 되는 것을 확인할 수 있음.

소변보다() 메서드가 수컷, 암컷 강아지의 행위를 모두 구현하려고 하기에 SRP를 위배하고 있는 것.

분기 처리를 위한 if else 문이 대표적인 냄새.

SRP를 적용하여 리팩터링 해보면 아래처럼 만들 수 있음.

```java
abstract class 강아지 {
	abstract void 소변보다();
}

class 수컷강아지 extends 강아지 {
	void 소변보다() {
		// 한쪽 다리를 들고 소변을 본다.
	}
}

class 암컷강아지 extends 강아지 {
	void 소변보다() {
		// 뒷다리 두 개로 앉은 자세로 소변을 본다.
	}
}
```

SRP와 가장 관계가 깊은 객체 지향 4대 특성은 추상화임.

애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 SRP를 고려하는 습관을 들여야 함.

## OCP - 개방 폐쇄 원칙

"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴

JDBC 처럼 사용하는 DBMS가 오라클에서 MySQL로 변경되더라도 Connection 정보를 수정하는 부분 외에는 클라이언트 코드는 수정할 필요가 없음.

편의점에서 일일 삼교대로 직원이 교대할 때, 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는데 영향이 없음.

유연성, 재사용성, 유지보수성 등을 얻을 수 있는 장점을 가지고 있음.

## LSP - 리스코프 치환 원칙

"서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마틴

하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다는 뜻.

객체 지향의 상속은 다음 조건들을 만족해야 함.

- 하위 클래스 is a kind of 상위 클래스
- 구현 클래스 is able to 인터페이스

```java
동물 고래 = new 고래();
동물 박쥐 = new 박쥐();
```

하위에 존재하는 것들은 상위에 있는 것들의 역할을 하는데 전혀 문제가 없음.

결국 LSP는 객체 지향의 상속 개념을 올바르게 적용하면 자연스럽게 얻게 됨.

## ISP - 인터페이스 분리 원칙

"클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다." - 로버트 C. 마틴

위의 단일 책임 원칙에서는 유지 보수에 효율적인 코드를 작성하기 위해 클래스의 역할과 책임을 분리하는 해결책을 제시하는데, 그렇게 다수의 클래스로 분리하지 않고 여러개의 인터페이스로 역할을 제한하는 방식이 ISP 임.

SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있음.

하지만 특별한 경우가 아니라면 SRP를 적용하는 것이 더 좋은 해결책임.

ISP에 대해 이야기 할 때 인터페이스 최소주의 원칙이 함께 등장하는 경우가 많음.

인터페이스 최소주의 원칙은 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공해서 해당 역할에만 충실할 수 있게 하라는 것.

상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋음.

상위 클래스가 풍성할수록 공통적으로 가지고 있는 속성과 메서드가 많아서 여기저기 형변환을 할 필요가 없어짐.

## DIP - 의존 역전 원칙

"고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."  
"추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."  
"자주 변경되는 구체 클래스에 의존하지 마라" - 로버트 C. 마틴

자동차의 경우 계절에 따라 다른 종류의 타이어로 교체할 수 있음. (스노우타이어, 일반타이어, 광폭타이어 등)

하지만 자동차 클래스가 특정 종류의 구체적인 타이어에 의존하게 설계를 한다면 타이어 종류를 변경할 때마다 자동차의 의존성을 수정해줘야 함.

하지만 타이어 인터페이스를 만들어서 자동차가 의존하게 한다면, 타이어가 바뀌어도 자동차 클래스 코드 수정이 필요 없어짐.

결국 OCP에 대한 내용임.

이렇게 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙임.

"자신보다 변하기 쉬운 것에 의존하지 마라." -> 의존 역전 원칙

변하기 쉬운 하위 클래스에 의존하기보다 상위 클래스, 인터페이스, 추상 클래스처럼 변할 가능성이 낮은 것에 의존하게 끔 하는 것.

대표적인 예시는 OCP와 마찬가지로 JDBC.

---

## Design Patterns

### Adapter Pattern

호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴.

(예시 추가 필요)

### Proxy Pattern

제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴.

- Proxy는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- Proxy는 실제 서비스에 대한 참조 변수를 갖는다(합성).
- Proxy는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 그대로 클라이언트에게 돌려준다. (중요)
- Proxy는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.

실제 서비스 클래스와 프록시 클래스 사이에 인터페이스를 두고 OCP와 DIP를 적용한 패턴임.

- 자동차 (마티즈도 될 수 있고, 소나타도 될 수 있고)
- 타이어 (스노우타이어, 일반타이어 등)

### Decorator Pattern

프록시 패턴은 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달함.

데코레이터 패턴은 해당 반환값에 장식을 입혀서 반환하는 용도로 사용함.

프록시 패턴과 동일한 구조를 가짐.

### Singleton Pattern

(알고 있어서 패스)

### Template Method Pattern

상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴.

```java
// Dog 클래스

public class Dog {
	public void playWithOwner() {
		System.out.println("귀염둥이 이리온~");
		System.out.println("멍멍!");
		System.out.println("꼬리 살랑 살랑~");
		System.out.println("잘했어");
	}
}
```

```java
// Cat 클래스

public class Cat {
	public void playWithOwner() {
		System.out.println("귀염둥이 이리온~");
		System.out.println("야옹 야옹");
		System.out.println("꼬리 살랑 살랑~");
		System.out.println("잘했어");
	}
}
```

위 예시에서 Dog 클래스와 Cat 클래스는 각각의 두번째 프린트문 빼고는 전부 동일한 작업을 수행함.

이럴 때 달라지는 동일한 부분만 상위 클래스에 두고, 달라지는 부분만 하위 클래스로 분할하여 효율적으로 수정할 수 있다.

```java
public abstract class Animal {
	// 템플릿 메서드
	public void playWithOwner() {
		System.out.println("귀염둥이 이리온~");
		play();
		runSomething();
		System.out.println("잘했어");
	}

	// 추상 메서드
	abstract void play();

	// Hook(갈고리) 메서드
	void runSomething() {
		System.out.println("꼬리 살랑 살랑~");
	}
}
```

```java
// Dog 클래스 (템플릿 메서드 패턴을 적용한)

public class Dog {
	// 추상 메서드 오버라이딩
	@Override
	void play() {
		System.out.println("멍멍!");
	}

	// Hook(갈고리) 메서드 오버라이딩
	@Override
	void runSomething() {
		System.out.println("멍멍! 꼬리 살랑 살랑~");
	}
}
```

```java
// Cat 클래스 (템플릿 메서드 패턴을 적용한)

public class Dog {
	// 추상 메서드 오버라이딩
	@Override
	void play() {
		System.out.println("야옹!");
	}

	// Hook(갈고리) 메서드 오버라이딩
	@Override
	void runSomething() {
		System.out.println("야옹! 꼬리 살랑 살랑~");
	}
}
```

```java
public class Driver {
	public static void main(String[] args) {
		Animal woong = new Dog();
		Animal kitty = new Cat();

		woong.playWithOwner();
		kitty.playWithOwner();
	}
}
```

상위클래스인 Animal는 아래와 같이 구성되어 있음.

- 템플릿을 제공하는 playWithOwner() 메서드
- 하위 클래스에게 구현을 강제하는 play() 추상 메서드
- 하위 클래스가 선택적으로 오버라이딩할 수 있는 runSomething() 메서드

### Factory Method Pattern

하위 클래스에서 팩터리 메서드를 오버라이드해서 객체를 반환하게 하는 것.

```java
public abstract class Animal {
	// 추상 팩터리 메서드
	abstract AnimalToy getToy();
}
```

```java
// 팩터리 메서드가 생성할 객체의 상위 클래스
public abstract class AnimalToy {
	abstract void identify();
}
```

```java
public class Dog extends Animal {
	// 추상 팩터리 메서드 오버라이드
	@Override
	AnimalToy getToy() {
		return new DogToy();
	}
}
```

```java
public class DogToy extends AnimalToy {
	@Override
	public void identify() {
		System.out.println("나는 테니스공! 강아지의 친구!");
	}
}
```

```java
public class Cat extends Animal {
	// 추상 팩터리 메서드 오버라이드
	@Override
	AnimalToy getToy() {
		return new CatToy();
	}
}
```

```java
public class CatToy extends AnimalToy {
	@Override
	public void identify() {
		System.out.println("나는 캣타워! 고양이의 친구!");
	}
}
```

```java
public class Driver {
	public static void main(String[] args) {
		// 팩터리 메서드를 보유한 객체들 생성
		Animal woong = new Dog();
		Animal kitty = new Cat();

		// 팩터리 메서드가 반환하는 객체들
		AnimalToy woongBall = woong.getToy();
		AnimalToy kittyTower = kitty.getToy();

		// 팩터리 메서드가 반환한 객체들을 사용
		woongBall.identify();
		kittyTower.identify();
	}
}
```

오버라이드된 메서드가 객체를 반환하는 패턴.

### Strategy Pattern

- 전략 메서드를 가진 전략 객체
- 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
- 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)

클라이언트는 다양한 전략 중 하나를 선택해 생성한 후 컨텍스트에 주입함.

즉, 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴.

### Template Callback Pattern

전략 패턴과 모든 것이 동일한데 전략을 익명 내부 클래스로 정의해서 사용함. (람다 활용하면 될 듯)
