# Internal API 개선기

상담신청/수강등록 현황, 상담신청 관리, 수강생 관리 기능을 제공하는 Admin API 개발에 투입하여 구조 개선 및 성능 개선 작업을 했던 경험을 공유합니다.

## 레거시 코드 구조 개선 (Layered Pattern, ORM 변경)

기존 Internal API의 뼈대를 구축했던 개발자들의 부재(퇴사, 팀 이동 등의 이유)로 인해 처음 접해본 기술인 Node.js와 GraphQL 기반 API 개발에 투입되었습니다. 기존 코드가 레이어드 패턴의 구조를 갖추고는 있었으나, 비즈니스 로직과 DAO 관련 로직이 관련 없는 레이어에 작성되어 있는 경우가 많아, 명확하지 않고 이해하기 어려운 구조를 가지고 있었습니다. 추가로, PrismaORM의 PrismaClient 객체에 대한 의존성이 매우 강한 구조를 띄고 있는 상태여서 그에 대한 해결책이 필요한 상태였습니다.

Internal API 개발 투입과 동시에 이 프로젝트를 통해 얻고자 하는 성장포인트들을 정리했습니다. 첫째로, 오래된 건물을 철거 후 재건축하듯, 기존 프로젝트에 존재했던 모든 코드를 검토하고 파악하면서 신규서비스를 개발한듯한 경험을 할 수 있다고 생각했습니다. 레거시 코드의 컨텍스트에 대한 이해가 없는 상태에서 빠른 시간내에 기존 코드를 파악하여 최신화하고 추가 팀원들이 함께 개발에 참여할 수 있는 시스템을 직접 구축해볼 수 있는 기회라는 생각에 많은 기대가 되었습니다. 둘째로, 평소 이론으로만 알고 있던 Single Responsibility Principle에 맞춰 개발하고 그 효과를 경험해볼 수 있다는 기대가 있었습니다. 셋째로, 상담신청 리스트 페이지에 검색 및 필터 조건이 많아 코드가 다소 지저분해질 수 있는 부분을 개선하기 위한 고민을 해볼 수 있는 기회라는 기대도 있었습니다. 마지막으로, 기존 코드에 GraphQL의 N+1 문제로 인해 호출 시 응답을 받을때까지 약 10초 이상 혹은 timeout이 걸리던 부분이 있어 해당 부분을 직접 해결해볼 수 있는 좋은 기회라는 생각에 기대가 되었습니다.

투입 첫 한달은 Node.js와 GraphQL에 적응하며 구조개선 작업에 몰두했습니다. 가장 먼저 resolver, service, model 구조에 맞춰 각 레이어에 관련없는 코드를 올바른 위치로 이동시키는 작업을 시작으로 기존 코드를 파악하는 시간을 가졌습니다. 그런 뒤 기존에 사용하던 PrismaORM에 대한 의존성이 매우 강한 구조를 변경하기 위한 논의 결과, ORM 사용의 가능성은 열어두고 SQL문으로 모든 DAO 로직을 작성하는 방향이 채택되었습니다. 당시 새로운 ORM을 선택하면서 고민했던 부분은 데이터베이스 커넥션을 생성하는 방식이 편하면서, ORM을 활용한 raw sql query 서포트가 좋은 ORM을 찾는 것이었습니다. 그렇게 TypeORM을 채택하게 되었고, 추후 활용도를 위해 데이터베이스 wrapper class를 만들어 프로젝트 전체적으로 적용한 뒤 가장 상단 PrismaClient만 TypeORM Connection으로 대체하였습니다. 추후 어떤 ORM을 사용하더라도 바뀌는 부분은 커넥션을 생성하는 곳과 Database wrapper class 내 메소드만 일부 수정해주면 되게끔 적용하였습니다.

## 상담신청서 리스트 검색 필터 보완

상담신청 리스트를 확인하는 페이지에는 상담신청자 이름, 이메일, 휴대폰 번호, 상담 메모 내역 등을 한번에 조회하는 keyword search, 다양한 range의 날짜 필터, 상담신청 구분 필터 등 다양한 필터 조건들이 존재합니다. 필터 조건이 몇가지 없고, 바뀔 일도 없다면 굳이 기존 코드를 고칠 필요는 없겠다고 생각했지만, 해당 기능에 대한 앞으로의 방향성을 파악하고자 기획미팅을 진행했고, 새로운 필터 조건들이 추가될 수 있는 점을 감안하여 확장성있는 구조로 변경하는 작업을 진행하기로 했습니다.

해당 부분에서는 들어오는 필터 조건에 따라 SQL문의 조건절을 만들어줘야했고, 기존 코드에는 이 부분이 조건문들을 활용한 분기처리 형태로 되어 있었습니다. 가독성이 좋지 못하고, 확장성도 좋지 않은 문제를 해결하기 위해 다양한 시도를 해본 후 최종적으로 SQL WHERE과 해당 조건에 따라 필요한 JOIN문을 빌드하는 필터 쿼리 빌더 클래스를 작성했습니다. 프론트엔드에서 GraphQL Query를 보낼때 Linked List의 형태로 조건문들을 담아주게끔 하여, 필터 쿼리 빌더 클래스에서는 재귀호출을 통해 필요한 JOIN문과 WHERE절을 추가하는 방식으로 작동했습니다.

하지만 프론트엔드에서 query string의 조건들을 GraphQL Query에 담는 과정에서 Linked List로 만들어줘야하는 부분이 불편하고 불필요한 작업이 많다는 피드백이 있어 몇 차례 논의를 진행하기도 했습니다. 그렇게 재귀호출 없이 각 조건에 해당하는 필터 빌더 인스턴스들을 모아 한번에 필요한 JOIN문과 WHERE절을 생성하는 방식으로 보완했습니다.

이렇게 변경하고나니 문제를 단순 로직으로 해결하기보다 구조를 통해 해결하려고 노력하라는 대표님의 가르침을 적용해볼 수 있는 기회여서 뿌듯했고, 입사 이후 처음으로 기능개발 관련하여 많은 논의를 하는 과정에서 협업의 즐거움을 느꼈습니다.

## 수강생 진도 파악 기능에서의 N+1 문제

현재 수강 진행중인 기수의 수강생 별 진도를 파악하는 페이지에는 선택한 기수 정보부터 수강생들의 과제 제출 현황을 파악하는 기능이 있습니다. 기존 코드에서는 해당 페이지에 필요한 모든 데이터가 depth가 5정도 되는 깊이로 nesting된 큰 크기의 GraphQL 쿼리로 호출되고 있었습니다. 그렇다보니 N+1문제가 각 depth별로 중첩되어 staging 환경 기준 평균 응답시간이 10초가 넘거나 어떨때는 timeout에 걸리기도 하는 상황이었습니다.

해당 문제에 대한 해결책을 고민하면서 GraphQL의 N+1 문제에 대해서 알아보니 Batching을 통해 N+1 문제를 해결할 수 있는 dataloader라는 라이브러리를 발견했습니다. 하지만 바로 이거다 하고 Batching을 적용하기보다, 하나의 쿼리로 모든 정보를 다 가져오려고 하는 부분부터 분리한 뒤 어느정도의 속도 개선이 있었는지 파악해보기로 했습니다. 결국 기존 쿼리를 3개의 쿼리들로 분리하여 각각 호출하는 방식으로 변경하여 엄청나게 유의미한 성능 개선 효과를 경험했습니다. 그럼에도 불구하고1300ms~3000ms 정도의 응답속도를 더 낮춰보고자 dataloader를 적용했습니다. 그 결과, Lambda의 cold start를 제외한 이외 호출건에서 staging 환경 기준 500ms 내외의 응답속도로 크게 줄어든 것을 확인했습니다.

어떤 문제를 해결하기 위해 한가지 해결책만 믿고 바로 적용하기보다, 그 외에 조금 더 본질적인 문제를 개선할 수 있는 해결책을 생각해내어 우선 적용해본 뒤 추가 해결책을 적용하여 성능 개선 효과를 극대화해본 소중한 경험이었습니다.
