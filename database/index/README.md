# Index란 무엇일까?

1. Full Table Scan
2. Index 동작 원리
3. Index 생성 및 벤치마킹
4. Index 단점
5. 자동 생성 Indexes

---

# Full Table Scan

Index가 뭔지 알아보기 전에 **Full Table Scan**에 대해서 알아보겠습니다.

```sql
SELECT *
FROM users
WHERE username = 'jamessoun93';
```

위 쿼리는 `users` 테이블 내 존재하는 모든 데이터 중 `username` 컬럼값이 `jamessoun93`인 데이터를 반환하는 쿼리입니다.

이런 쿼리를 실행할 때 Postgres 내부에서는 어떤일이 일어날까요?

제가 이전에 작성한 [Postgres는 데이터를 어디에 어떤 형태로 저장할까?](https://seunghyunson.tistory.com/16) 하단의 **Postgres는 데이터를 어떤 형태로 저장할까?** 파트를 보면, 테이블 하나에 대한 데이터는 하나의 **Heap File**로 저장된다는 것을 알 수 있습니다.

하지만 해당 테이블의 전체 데이터는 여러개의 **Block**으로 그룹지어져 저장되어 있는 형태이기 때문에 Postgres가 바로 **Heap File**에 접근해서 스캔을 시작할 수 없습니다.

그래서 스캔할 대상이 되는 모든 데이터를 메모리에 모아놓고 메모리에서 순차적으로 하나하나 확인을 하면서 원하는 데이터를 찾습니다. (아래 다이어그램 확인)

![1](./images/1.png)

Heap 파일로부터 모든 데이터를 메모리로 옮겨 데이터 하나하나 원하는 조건에 맞는지 확인하는 작업이 바로 **Full Table Scan**입니다.

메모리로 옮겨야할 데이터가 많으면 많을수록 전체적인 비용이 커지고 성능에 영향을 주는 작업입니다.

그러므로 꼭 **Full Table Scan**이 필요한지에 대한 고민이 필요하고 더 성능 효율적인 방법이 존재한다면 다른 방법을 선택할 수 있어야합니다.

---

# Index 동작 원리

```sql
SELECT *
FROM users
WHERE username = 'jamessoun93';
```

그렇다면 위와 같은 쿼리를 날릴 때 매번 메모리에 데이터를 로드한 뒤 Full Table Scan을 하는것이 아니라, 내가 원하는 데이터가 정확하게 어떤 Block의 몇번째 인덱스에 존재하는지 알려줄 수 있는 방법은 없을까요?

**Index**를 활용하면 가능합니다.

![2](./images/2.png)

데이터베이스 Index는 요청한 데이터가 어떤 Block의 몇 번째 인덱스에 존재하는지를 알려주는 자료구조입니다.

인덱스는 내가 찾고자 하는 데이터를 담고 있는 **컬럼**을 기준으로 생성합니다.  
해당 컬럼값을 찾을 때 속도 효율을 높여주기 위해서죠.

그래서 인덱스 사용을 고려할 때 가장 첫 번째로 해야할 것이 어떤 컬럼을 기준으로 인덱스를 생성할건지 정하는 것입니다.

그렇다면 인덱스가 내부적으로 어떻게 생성되고 어떻게 사용되는지 보겠습니다.

## Index 생성 과정

1. 기준이 될 컬럼의 데이터를 수집합니다.
2. 수집한 데이터를 정렬합니다.
3. 정렬된 데이터를 Tree 구조로 만들어 정리합니다.

### 1. 수집

여기서는 `username` 컬럼을 기준으로 정하겠습니다.

Heap File에서 Block 마다 존재하는 데이터(row)마다 확인하면서 `username`에 대한 데이터를 수집합니다.  
(username 외 다른 정보는 수집하지 않습니다.)

![3](./images/3.png)

위의 다이어그램과 같은 형태로 각 `username` 데이터마다 해당 데이터가 어떤 block의 몇 번째 index에 존재하는지를 수집합니다.

### 2. 정렬

그런 뒤 이렇게 수집한 데이터를 정렬합니다.

정렬 방식은 수집한 데이터에 따라 다릅니다.

지금과 같은 string인 경우 알파벳순으로 정렬하고, 숫자/날짜 같은 값은 오름차순/내림차순으로 정렬할 수 있습니다.

![4](./images/4.png)

### 3. Tree 구조로 정리

위에서 특정 기준으로 정렬된 데이터를 이제 Tree 구조로 정리합니다.

![5](./images/5.png)

여기서 데이터를 가장 왼쪽 **leaf node**부터 순서대로 오른쪽으로 추가합니다.

**leaf node**들만 확인해도 왼쪽에서 오른쪽으로 기존의 정렬 상태를 그대로 유지하는 것을 확인할 수 있습니다. (여기서는 알파벳순)

그런뒤 **root node**에는 조건에 따라 방향을 말해주는 **helper를** 추가합니다.

**Root node**의 **helper는** 어떤 **leaf node**를 확인해야하는지 알려줘서, 조건에 맞는 데이터를 담고 있는 **leaf node**만 확인하면되게 해줍니다. (다른 **leaf node**를 확인할 필요가 없게 해준다는 뜻이죠.)

## Index 동작 과정

그렇다면 이제 위의 작업을 걸쳐 생성된 인덱스가 사용되는 과정을 살펴보겠습니다.

![6](./images/6.png)

제가 찾고자 하는 데이터는 `username` 값이 `jamessoun93`과 일치하는 row입니다.

1. Root node에서 좌측 조건에 맞지 않으니 우측 조건을 살펴본 뒤 해당 조건에 맞는지 확인합니다.
2. 우측 leaf node에서 미리 수집해놓은 `jamessoun93`이란 `username`을 가진 데이터의 위치(Block, Index)를 파악합니다.
3. Heap file에서 곧장 해당 위치에 있는 데이터를 찾습니다.

인덱스를 사용하면 어떤 이점이 있는지 이제 좀 보이시나요?

내가 원하는 데이터가 어디에 있는지 말해주는 **root node**의 **helper를** 이용하여 **좌측 leaf node**는 확인할 필요도 없이 **우측 leaf node**만 확인하면 됩니다.

그리고 해당 **leaf node**에서 찾는 데이터가 **heap file**의 **Block 1**에 있다는 사실을 알고 **Block 0**는 확인할 필요도 없이 원하는 데이터를 찾을 수 있는 것이죠.

**Full Table Scan**처럼 원하는 데이터를 찾을때까지 모든 데이터를 메모리에 로드한 뒤 하나하나 확인하는 방식보다 훨씬 빠를 수 밖에 없겠죠?

---

# Index 생성 및 벤치마킹

지금까지 인덱스가 어떻게 생성되는지 그리고 생성된 인덱스가 어떻게 사용되는지를 알아봤으니 실제로 인덱스를 생성해보겠습니다.

인덱스를 생성하는 문법은 아래와 같습니다.
```sql
CREATE INDEX ON 테이블명 (컬럼명);
```

(!!!!!!!!!!!!!!여기부터 수정필요)

`users_username_idx`라는 이름으로 인덱스가 생성됨.

인덱스 삭제하려면
```sql
DROP INDEX users_username_idx;
```

실제로 인덱스를 사용하면 속도가 빨라지는지 테스트 해보기

`users` 테이블에 총 5340개의 데이터가 있고

인덱스 없이

![7](./images/7.png)

인덱스 있이

![8](./images/8.png)

여기서는 약 29배정도 빠름

---

# Index 단점

그럼 매번 사용하면 되지 않을까?

크게 도움이 되지 않거나 오히려 비효율적인 경우도 있음.

## 1. 저장공간

인덱스도 마찬가지로 컴퓨터의 저장 공간을 사용함.

실제로 얼마나 잡아먹는지 확인도 할 수 있음.

우선 `users` 테이블이 얼마만큼의 공간을 사용하고 있는지 확인해보자.

```sql
SELECT pg_size_pretty(pg_relation_size('users'));
```

![9](./images/9.png)

인덱스는?
```sql
SELECT pg_size_pretty(pg_relation_size('users_username_idx'));
```

![10](./images/9.png)

880kb 와 184kb 정도면 뭐 얼마되지도 않고 좋네~ 

할 수 있지만 엄청나게 많은 데이터를 핸들링하는 서비스라서 테이블 데이터가 880kb가 아니라 80gb라면 인덱스의 크기도 18gb 정도가 될텐데 요즘처럼 데이터베이스도 호스팅해서 비용을 지불하고 사용하는 시대에 과연 저정도 storage에 대한 금액을 매번 내는게 부담스럽지 않을까?

결국 인덱스도 저장공간을 차지한다는게 포인트.

## 2. 업데이트

테이블에 데이터가 추가, 업데이트, 삭제될 때마다 인덱스도 업데이트 해줘야 하기때문에 느려질 수 있음. 

20개의 데이터를 따로따로 INSERT 한다고 가정한다면 인덱스도 20번 업데이트 해줘야한다는 뜻. (performance cost가 무조건 있을 수 밖에 없다.)

## 3. 사용 X

인덱스가 존재한다고해서 Postgres가 꼭 사용하는게 아님.

아무 영향이 없음.

이러이러한 이유들 때문에 빨라보인다고 모든 컬럼에 인덱스를 적용하면 안됨.