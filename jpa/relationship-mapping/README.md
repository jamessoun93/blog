# JPA: 연관관계 매핑 (Relationship Mapping)

_"객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다." - 조영호(객체지향의 사실과 오해)_

중요한 부분

양방향 연관관계와 연관관계의 주인

데이터베이스 테이블 관계에서는 FK만 있으면 양쪽으로 원하는 데이터를 가져올 수 있음.

하지만 엔티티 모델에서는 한쪽에서만 가능함

그러다 보니 엔티티 클래스에 양쪽에 대한 레퍼런스를 걸어 놓으면 어떻게 해야할지 막막함.

이럴 때 연관관계의 주인(Owner)을 정해줘야함.

양방향 매핑 규칙

- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X (내가 무언가에 의해서 매핑이 되었어 라는 뜻)
- 주인이 아니면 mappedBy 속성으로 지정
- 결국 mappedBy 걸린쪽은 읽기만 가능
- 외래키가 있는 곳을 주인으로 정해라 (OneToMany 쪽)

양방향 매핑시 가장 많이 하는 실수 (연관관계의 주인에 값을 입력하지 않음)

- mappedBy 쪽은 읽기 전용이라 JPA가 변경사항을 적용하지 않음.
- 그래서 역방향에서만 넣으면 외래키가 null이 될 수 있음.
- JPA 입장에서는 주인에만 넣어주면 되지만 객체지향을 고려해서 양쪽에 다 넣어주는게 좋음.
- 이게 양방향으로 안넣어주면 문제가 발생할 수 있는데
  - em.flush(); em.clear(); 안해주면 최초에 생성된게 그대로 1차 캐시에 들어있고 조회시 바로 거기서 가져오기 때문에 주인쪽에서 넣어준다 하더라도 데이터가 안들어올 수 있음.
- best practice

  - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정해주자
  - 연관관계 편의 메서드를 생성해주자

  ```java
  Team team = new Team();
  team setName("TeamA");
  em.persist(team);

  Member member = new Member();
  member.setUsername("member1");
  member.setTeam(team);
  em.persist(member);

  team.getMembers().add(member); // <- 이렇게 하지말고
  ```

  ```java
  // Member 엔티티 클래스에 편의 메서드 제공
  // 아니면 Team 쪽에 만들어도 무관

  public void assignTeam(Team team) {
      this.team = team;
      team.getMembers().add(this);
  }
  ```

  - 무한 루프를 조심하자
    - 예) toString(), lombok, JSON 생성 라이브러리 같은 것들
    - toString() 같은 것들 양쪽으로 무한으로 호출함.
    - 그래서 컨트롤러 같은데서 엔티티 직접 반환하지말고 DTO 사용해서 반환.
      - 엔티티가 변경된채로 그대로 반환하게 되면 API 스펙 자체가 변경되어버리는 문제도 발생할 수 있음.

실무 Best Practices

- 최초 JPA 설계시 우선 단방향 매핑으로 설계를 완료해라. (단방향 매핑만으로도 이미 연관관계 매핑은 완료)
- 단방향 매핑을 잘 해두면 양방향 매핑은 필요할 때 테이블에 영향없이 추가하면 되는 부분임

---

일대일 매핑 시 trade off 고려사항

외래키를 어디에 놓을 것인가

주 테이블에 외래 키

- 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음.
- 객체지향 개발자 선호
- JPA 매핑 편리
- 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
- 단점: 값이 없으면 외래 키에 null 허용

대상 테이블에 외래 키

- 대상 테이블에 외래 키가 존재
- 전통적인 데이터베이스 개발자 선호
- 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
- 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

다대다 사용 시 문제점 (이런 이유로 실무에서 사용 안함)

- 연결만 해주고 중간 테이블에 추가 정보를 넣을 수가 없음
- 그래서 연결 테이블용 엔티티 추가해서 @OneToMany와 @ManyToOne 으로
- 연결 테이블 PK도 웬만하면 복합키 말고 GeneratedValue 사용하는게 유연함
- PK가 어딘가에 종속되어 있는 형태로 만들어지면 유연하지가 못함
  - 예를 들어, 복합키에 추가해야하는 컬럼이 생길 경우?
- UUID 혹은 GeneratedValue 사용하는게 편하다고 생각
- 복합키 사용 vs GeneratedValue 사용 트레이드오프 생각해보기
