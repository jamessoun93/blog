# JPA: 영속성 컨텍스트 (Persistence Context)

- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 매니저는 쓰레드간에 공유하지 않음 (사용하고 버려야 함)
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

## JPQL

- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
- JPQL은 엔티티 객체를 대상으로 쿼리
- SQL은 데이터베이스 테이블을 대상으로 쿼리
- 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존X
- JPQL을 한마디로 정의하면 객체 지향 SQL

## 영속성 컨텍스트

### 영속 상태

- 엔티티 매니저의 persist 메서드를 통해 객체를 등록하면 영속 상태가 됨.
- 새로 생성뿐만 아니라 find도 영속 상태를 만들어줌.
  - 없으면 DB 조회해서 1차 캐시에 넣어놓기 때문에
- 영속 상태가 된다고 해서 DB 쿼리가 바로 날라가는 것이 아님.
- 트랜잭션 커밋 시점에 DB 쿼리가 날라감.

### 준영속 상태

- 영속 상태의 엔티티가 영속성 컨텍스에서 분리되는 것 (detached)
- 영속성 컨텍스트가 제공하는 기능들을 사용할 수 없음
- 준영속 상태로 만드는 방법 (거의 할 일 없음)
  - detach -> 특정 엔티티만 준영속 상태로 만듬
  - clear -> 영속성 컨텍스트를 밀어버림
  - close -> 영속성 컨텍스트를 닫아버림

## 영속성 컨텍스트의 이점

### 1차 캐시

- key가 @Id 즉 PK로 맵핑한 값이고 값은 Entity 객체 자체가 된다.
- em.find: 먼저 1차 캐시를 조회하고 없다면 DB에서 가져와서 1차 캐시에 저장 후 반환
- 하나의 DB 트랜잭션 동안만 살아있기 때문에 큰 성능 개선 효과는 기대하기 힘듬
- 동시요청이 여럿 있을 때 성능상 도움을 주는 형태가 아니라는 뜻.

### 영속 엔티티의 동일성 보장

```java
Member member1 = em.find(Member.class, 101L);
Member member2 = em.find(Member.class, 101L);

// 동일성 보장 (true)
System.out.println(member1 == member2);
```

### 트랜잭션을 지원하는 쓰기 지연

영속성 컨텍스트에는 1차 캐시 말고도 쓰기 지연 SQL 저장소라는 것이 존재함.

```java
em.persist(member1)
```

위와 같이 member1 객체를 persist 하면, 1차 캐시에 저장됨과 동시에 해당하는 insert문이 쓰기 지연 저장소에 등록됨.

만약 여기서 member2 객체를 추가로 persist 하면 똑같이 1차 캐시에 추가되고 쓰기 지연 저장소에 insert문이 추가됨.

쓰기 지연 저장소에서 SQL문들을 들고 있다가 트랜잭션 커밋 시점에 DB로 flush되고 실제 DB 커밋이 실행됨.

한번에 몇개까지 처리할 수 있느냐에 대한 것은 아래 설정을 추가하여 관리할 수 있음.

```xml
<property name="hibernate.jdbc.batch_size" value="10"/>
```

### 변경 감지 (Dirty Checking)

- JPA 목적이 마치 자바 컬렉션을 다루듯이 객체를 다루는 것.
- 엔티티 값 변경할 때 자바 컬렉션에서 하는 것 처럼 그냥 setter 써서 변경하면 된다. (persist 별도 호출 불필요)
- 1차 캐시에는 key, entity와 최초 읽어들였을 당시 스냅샷이 함께 포함되어 있다.
- 이때 commit에 의한 flush가 발생하면 엔티티와 스냅샷을 비교하여 변경된 값이 있는지 확인한다.
- 만약 변경된 내용이 있다면 update 쿼리를 쓰기 지연 저장소에 추가한다.
- transaction이 커밋되는 시점에 쓰기 지연 저장소에 있던 쿼리들과 같이 flush 된다.

### Lazy Loading

- (추가 필요)

## Flush

- 영속성 컨텍스트의 변경내용을 DB에 반영
- flush가 발생될 때 일어나는 일
  - 변경 감지
  - 수정된 엔티티에 대한 sql문을 쓰기 지연 저장소에 등록
  - DB 호출
- flush 하는 방법 (실제로 이렇게 할 일은 드물다)
  - em.flush() 직접 호출
    - persist만 한 상태에서 commit 전에는 아직 쿼리가 안날라가기 때문에 미리 쿼리를 확인하고 싶은 경우
  - 트랜잭션 커밋 - 자동 호출
  - JPQL 쿼리 실행 - 자동 호출
- flush 한다고 1차 캐시가 비워지는 것이 아니라 변경 감지 후 쓰기 지연 저장소에 있는 쿼리들이 DB에 반영됨.
- 결국 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨.
